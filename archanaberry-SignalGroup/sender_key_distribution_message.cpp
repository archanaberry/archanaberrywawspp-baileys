#include <string>
#include <vector>
#include <stdexcept>
#include "base64.hpp" // You would need to create this header file or include a library that provides base64 encoding and decoding functions
#include "ciphertext_message.hpp" // You would need to create this header file or include a library that provides the CiphertextMessage class
#include "sender_key_distribution_message.pb-c.h" // This is the header file generated by protobuf-c for your .proto file

class SenderKeyDistributionMessage : public CiphertextMessage {
private:
uint8_t* serialized;
size_t serialized_length;
uint32_t id;
uint32_t iteration;
uint8_t* chainKey;
uint8_t* signatureKey;

public:
    std::vector<uint8_t> getChainKey() const {
        if (chainKey == nullptr) {
            throw std::runtime_error("Chain key is null");
        }
        // Assuming that chainKey is already a base64 encoded string
        return Base64::decode(std::string(reinterpret_cast<const char*>(chainKey)));
    }

    std::vector<uint8_t> getSignatureKey() const {
        if (signatureKey == nullptr) {
            throw std::runtime_error("Signature key is null");
        }
        // Assuming that signatureKey is already a base64 encoded string
        return Base64::decode(std::string(reinterpret_cast<const char*>(signatureKey)));
    }

    uint32_t getId() const {
        return id;
    }

SenderKeyDistributionMessage(uint32_t id = 0, uint32_t iteration = 0, const uint8_t* chainKey = nullptr, const uint8_t* signatureKey = nullptr, const uint8_t* serialized = nullptr, size_t serialized_length = 0)
: id(id), iteration(iteration), chainKey(nullptr), signatureKey(nullptr), serialized(nullptr), serialized_length(0) {
if (serialized) {
ProtobufCMessage* message = nullptr;
SenderKeyDistributionMessage__unpack(nullptr, serialized_length, serialized);
if (message) {
auto distributionMessage = reinterpret_cast<SenderKeyDistributionMessage*>(message);
this->id = distributionMessage->id;
this->iteration = distributionMessage->iteration;
this->chainKey = distributionMessage->chain_key.data;
this->signatureKey = distributionMessage->signature_key.data;
this->serialized = new uint8_t[serialized_length];
memcpy(this->serialized, serialized, serialized_length);
this->serialized_length = serialized_length;
SenderKeyDistributionMessage__free_unpacked(distributionMessage, nullptr);
} else {
throw std::runtime_error("Failed to unpack SenderKeyDistributionMessage");
}
} else {
uint8_t version = intsToByteHighAndLow(CURRENT_VERSION, CURRENT_VERSION);
SenderKeyDistributionMessage message = SENDER_KEY_DISTRIBUTION_MESSAGE__INIT;
message.id = id;
message.iteration = iteration;
message.chain_key.data = const_cast<uint8_t*>(chainKey);
message.chain_key.len = chainKey ? strlen(reinterpret_cast<const char*>(chainKey)) : 0;
message.signature_key.data = const_cast<uint8_t*>(signatureKey);

message.signature_key.len = signatureKey ? strlen(reinterpret_cast<const char*>(signatureKey)) : 0;
size_t len = sender_key_distribution_message__get_packed_size(&message);
uint8_t* buf = new uint8_t[len + 1];
buf[0] = version;
sender_key_distribution_message__pack(&message, buf + 1);
this->serialized = buf;
this->serialized_length = len + 1;
}
}

~SenderKeyDistributionMessage() {
delete[] chainKey;
delete[] signatureKey;
delete[] serialized;
}

uint8_t intsToByteHighAndLow(uint8_t highValue, uint8_t lowValue) {
return ((highValue << 4) | lowValue) & 0xff;
}

const uint8_t* serialize(size_t& length) {
length = serialized_length;
return serialized;
}

uint32_t getType() {
return SENDERKEY_DISTRIBUTION_TYPE;
}

uint32_t getIteration() {
return iteration;
}
};
